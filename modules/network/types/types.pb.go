// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: rollkitsdk/network/v1/types.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	_ "google.golang.org/protobuf/types/known/durationpb"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// SignMode defines when validators must sign
type SignMode int32

const (
	// SIGN_MODE_UNSPECIFIED is invalid
	SignMode_SIGN_MODE_UNSPECIFIED SignMode = 0
	// SIGN_MODE_CHECKPOINT means validators sign only at checkpoint heights
	SignMode_SIGN_MODE_CHECKPOINT SignMode = 1
)

var SignMode_name = map[int32]string{
	0: "SIGN_MODE_UNSPECIFIED",
	1: "SIGN_MODE_CHECKPOINT",
}

var SignMode_value = map[string]int32{
	"SIGN_MODE_UNSPECIFIED": 0,
	"SIGN_MODE_CHECKPOINT":  1,
}

func (x SignMode) String() string {
	return proto.EnumName(SignMode_name, int32(x))
}

func (SignMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6ae6db90f9054c5e, []int{0}
}

// Params defines the parameters for the network module.
type Params struct {
	// epoch_length is the number of blocks per attestation window
	EpochLength uint64 `protobuf:"varint,1,opt,name=epoch_length,json=epochLength,proto3" json:"epoch_length,omitempty"`
	// quorum_fraction is the voting power needed for soft-finality (e.g., "2/3")
	QuorumFraction string `protobuf:"bytes,2,opt,name=quorum_fraction,json=quorumFraction,proto3" json:"quorum_fraction,omitempty"`
	// min_participation is the ejection threshold inside an epoch (e.g., "1/2")
	MinParticipation string `protobuf:"bytes,3,opt,name=min_participation,json=minParticipation,proto3" json:"min_participation,omitempty"`
	// prune_after is the number of epochs to retain attestation bitmaps
	PruneAfter uint64 `protobuf:"varint,4,opt,name=prune_after,json=pruneAfter,proto3" json:"prune_after,omitempty"`
	// sign_mode determines when validators must sign
	SignMode SignMode `protobuf:"varint,5,opt,name=sign_mode,json=signMode,proto3,enum=rollkitsdk.network.v1.SignMode" json:"sign_mode,omitempty"`
}

func (m *Params) Reset()         { *m = Params{} }
func (m *Params) String() string { return proto.CompactTextString(m) }
func (*Params) ProtoMessage()    {}
func (*Params) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ae6db90f9054c5e, []int{0}
}
func (m *Params) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Params.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Params) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Params.Merge(m, src)
}
func (m *Params) XXX_Size() int {
	return m.Size()
}
func (m *Params) XXX_DiscardUnknown() {
	xxx_messageInfo_Params.DiscardUnknown(m)
}

var xxx_messageInfo_Params proto.InternalMessageInfo

func (m *Params) GetEpochLength() uint64 {
	if m != nil {
		return m.EpochLength
	}
	return 0
}

func (m *Params) GetQuorumFraction() string {
	if m != nil {
		return m.QuorumFraction
	}
	return ""
}

func (m *Params) GetMinParticipation() string {
	if m != nil {
		return m.MinParticipation
	}
	return ""
}

func (m *Params) GetPruneAfter() uint64 {
	if m != nil {
		return m.PruneAfter
	}
	return 0
}

func (m *Params) GetSignMode() SignMode {
	if m != nil {
		return m.SignMode
	}
	return SignMode_SIGN_MODE_UNSPECIFIED
}

// AttestationBitmap stores the bitmap and metadata for a checkpoint
type AttestationBitmap struct {
	// height is the checkpoint height
	Height int64 `protobuf:"varint,1,opt,name=height,proto3" json:"height,omitempty"`
	// bitmap is the validator participation bitmap
	Bitmap []byte `protobuf:"bytes,2,opt,name=bitmap,proto3" json:"bitmap,omitempty"`
	// voted_power is the total voting power that attested
	VotedPower uint64 `protobuf:"varint,3,opt,name=voted_power,json=votedPower,proto3" json:"voted_power,omitempty"`
	// total_power is the total voting power at this height
	TotalPower uint64 `protobuf:"varint,4,opt,name=total_power,json=totalPower,proto3" json:"total_power,omitempty"`
	// soft_confirmed indicates if quorum was reached
	SoftConfirmed bool `protobuf:"varint,5,opt,name=soft_confirmed,json=softConfirmed,proto3" json:"soft_confirmed,omitempty"`
}

func (m *AttestationBitmap) Reset()         { *m = AttestationBitmap{} }
func (m *AttestationBitmap) String() string { return proto.CompactTextString(m) }
func (*AttestationBitmap) ProtoMessage()    {}
func (*AttestationBitmap) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ae6db90f9054c5e, []int{1}
}
func (m *AttestationBitmap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AttestationBitmap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AttestationBitmap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AttestationBitmap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttestationBitmap.Merge(m, src)
}
func (m *AttestationBitmap) XXX_Size() int {
	return m.Size()
}
func (m *AttestationBitmap) XXX_DiscardUnknown() {
	xxx_messageInfo_AttestationBitmap.DiscardUnknown(m)
}

var xxx_messageInfo_AttestationBitmap proto.InternalMessageInfo

func (m *AttestationBitmap) GetHeight() int64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *AttestationBitmap) GetBitmap() []byte {
	if m != nil {
		return m.Bitmap
	}
	return nil
}

func (m *AttestationBitmap) GetVotedPower() uint64 {
	if m != nil {
		return m.VotedPower
	}
	return 0
}

func (m *AttestationBitmap) GetTotalPower() uint64 {
	if m != nil {
		return m.TotalPower
	}
	return 0
}

func (m *AttestationBitmap) GetSoftConfirmed() bool {
	if m != nil {
		return m.SoftConfirmed
	}
	return false
}

// ValidatorIndex maps a validator address to its bitmap index
type ValidatorIndex struct {
	// address is the validator operator address
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// index is the position in the bitmap
	Index uint32 `protobuf:"varint,2,opt,name=index,proto3" json:"index,omitempty"`
	// power is the cached voting power
	Power uint64 `protobuf:"varint,3,opt,name=power,proto3" json:"power,omitempty"`
}

func (m *ValidatorIndex) Reset()         { *m = ValidatorIndex{} }
func (m *ValidatorIndex) String() string { return proto.CompactTextString(m) }
func (*ValidatorIndex) ProtoMessage()    {}
func (*ValidatorIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ae6db90f9054c5e, []int{2}
}
func (m *ValidatorIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidatorIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidatorIndex.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidatorIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidatorIndex.Merge(m, src)
}
func (m *ValidatorIndex) XXX_Size() int {
	return m.Size()
}
func (m *ValidatorIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidatorIndex.DiscardUnknown(m)
}

var xxx_messageInfo_ValidatorIndex proto.InternalMessageInfo

func (m *ValidatorIndex) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *ValidatorIndex) GetIndex() uint32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *ValidatorIndex) GetPower() uint64 {
	if m != nil {
		return m.Power
	}
	return 0
}

func init() {
	proto.RegisterEnum("rollkitsdk.network.v1.SignMode", SignMode_name, SignMode_value)
	proto.RegisterType((*Params)(nil), "rollkitsdk.network.v1.Params")
	proto.RegisterType((*AttestationBitmap)(nil), "rollkitsdk.network.v1.AttestationBitmap")
	proto.RegisterType((*ValidatorIndex)(nil), "rollkitsdk.network.v1.ValidatorIndex")
}

func init() { proto.RegisterFile("rollkitsdk/network/v1/types.proto", fileDescriptor_6ae6db90f9054c5e) }

var fileDescriptor_6ae6db90f9054c5e = []byte{
	// 562 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x93, 0x4f, 0x6f, 0xd3, 0x30,
	0x14, 0xc0, 0x9b, 0xfd, 0xa3, 0xf5, 0xb6, 0xd2, 0x45, 0x1d, 0xca, 0x76, 0xc8, 0xba, 0x4a, 0x48,
	0x15, 0x52, 0x13, 0x6d, 0x1c, 0x90, 0x00, 0x09, 0xf5, 0xdf, 0xa0, 0x82, 0x75, 0x55, 0x3a, 0x38,
	0x70, 0x89, 0xdc, 0xc4, 0x4d, 0xad, 0x26, 0x79, 0xc1, 0x76, 0xba, 0x71, 0xe3, 0x23, 0xf0, 0x41,
	0x38, 0xee, 0x43, 0x70, 0x9c, 0x76, 0xe2, 0x88, 0xda, 0x2f, 0x82, 0xe2, 0xb8, 0x6c, 0x87, 0xdd,
	0xfc, 0x7e, 0xef, 0xe7, 0xf8, 0xbd, 0xe7, 0x18, 0x1d, 0x33, 0x08, 0xc3, 0x19, 0x15, 0xdc, 0x9f,
	0xd9, 0x31, 0x11, 0x57, 0xc0, 0x66, 0xf6, 0xfc, 0xc4, 0x16, 0xdf, 0x13, 0xc2, 0xad, 0x84, 0x81,
	0x00, 0x7d, 0xff, 0x5e, 0xb1, 0x94, 0x62, 0xcd, 0x4f, 0x0e, 0xab, 0x01, 0x04, 0x20, 0x0d, 0x3b,
	0x5b, 0xe5, 0xf2, 0xe1, 0x81, 0x07, 0x3c, 0x02, 0xee, 0xe6, 0x89, 0x3c, 0x50, 0x29, 0x33, 0x00,
	0x08, 0x42, 0x62, 0xcb, 0x68, 0x9c, 0x4e, 0x6c, 0x3f, 0x65, 0x58, 0x50, 0x88, 0xf3, 0x7c, 0xfd,
	0xc7, 0x1a, 0xda, 0x1a, 0x62, 0x86, 0x23, 0xae, 0x1f, 0xa3, 0x1d, 0x92, 0x80, 0x37, 0x75, 0x43,
	0x12, 0x07, 0x62, 0x6a, 0x68, 0x35, 0xad, 0xb1, 0xe1, 0x6c, 0x4b, 0xf6, 0x49, 0x22, 0xfd, 0x15,
	0x7a, 0xfa, 0x2d, 0x05, 0x96, 0x46, 0xee, 0x84, 0x61, 0x2f, 0xfb, 0x8c, 0xb1, 0x56, 0xd3, 0x1a,
	0xa5, 0x76, 0xf9, 0xee, 0xa6, 0x89, 0xd4, 0xc1, 0x5d, 0xe2, 0x39, 0xe5, 0x5c, 0x3b, 0x53, 0x96,
	0xfe, 0x06, 0xed, 0x45, 0x34, 0x76, 0x13, 0xcc, 0x04, 0xf5, 0x68, 0x22, 0x2b, 0x30, 0xd6, 0x1f,
	0xdd, 0x5a, 0x89, 0x68, 0x3c, 0x7c, 0xe8, 0xe9, 0x47, 0x68, 0x3b, 0x61, 0x69, 0x4c, 0x5c, 0x3c,
	0x11, 0x84, 0x19, 0x1b, 0xb2, 0x2e, 0x24, 0x51, 0x2b, 0x23, 0xfa, 0x5b, 0x54, 0xe2, 0x34, 0x88,
	0xdd, 0x08, 0x7c, 0x62, 0x6c, 0xd6, 0xb4, 0x46, 0xf9, 0xf4, 0xc8, 0x7a, 0x74, 0x80, 0xd6, 0x88,
	0x06, 0xf1, 0x39, 0xf8, 0xc4, 0x29, 0x72, 0xb5, 0xaa, 0xff, 0xd2, 0xd0, 0x5e, 0x4b, 0x08, 0xc2,
	0x85, 0x3c, 0xae, 0x4d, 0x45, 0x84, 0x13, 0xfd, 0x19, 0xda, 0x9a, 0x12, 0x1a, 0x4c, 0x85, 0x9c,
	0xc3, 0xba, 0xa3, 0xa2, 0x8c, 0x8f, 0xa5, 0x21, 0x3b, 0xdf, 0x71, 0x54, 0x94, 0x15, 0x39, 0x07,
	0x41, 0x7c, 0x37, 0x81, 0x2b, 0xc2, 0x64, 0x6f, 0x1b, 0x0e, 0x92, 0x68, 0x98, 0x91, 0x4c, 0x10,
	0x20, 0x70, 0xa8, 0x04, 0xd5, 0x85, 0x44, 0xb9, 0xf0, 0x1c, 0x95, 0x39, 0x4c, 0x84, 0xeb, 0x41,
	0x3c, 0xa1, 0x2c, 0x22, 0xbe, 0x6c, 0xa5, 0xe8, 0xec, 0x66, 0xb4, 0xb3, 0x82, 0xf5, 0x04, 0x95,
	0xbf, 0xe0, 0x90, 0xfa, 0x58, 0x00, 0xeb, 0xc7, 0x3e, 0xb9, 0xd6, 0x4f, 0xd1, 0x13, 0xec, 0xfb,
	0x8c, 0x70, 0x2e, 0x6b, 0x2d, 0xb5, 0x8d, 0xbb, 0x9b, 0x66, 0x55, 0x8d, 0xb4, 0x95, 0x67, 0x46,
	0x82, 0xd1, 0x38, 0x70, 0x56, 0xa2, 0x5e, 0x45, 0x9b, 0x34, 0xdb, 0x2c, 0xbb, 0xd8, 0x75, 0xf2,
	0x20, 0xa3, 0x0f, 0xcb, 0xcf, 0x83, 0x17, 0xef, 0x50, 0x71, 0x35, 0x36, 0xfd, 0x00, 0xed, 0x8f,
	0xfa, 0xef, 0x07, 0xee, 0xf9, 0x45, 0xb7, 0xe7, 0x7e, 0x1e, 0x8c, 0x86, 0xbd, 0x4e, 0xff, 0xac,
	0xdf, 0xeb, 0x56, 0x0a, 0xba, 0x81, 0xaa, 0xf7, 0xa9, 0xce, 0x87, 0x5e, 0xe7, 0xe3, 0xf0, 0xa2,
	0x3f, 0xb8, 0xac, 0x68, 0xed, 0xcb, 0xdf, 0x0b, 0x53, 0xbb, 0x5d, 0x98, 0xda, 0xdf, 0x85, 0xa9,
	0xfd, 0x5c, 0x9a, 0x85, 0xdb, 0xa5, 0x59, 0xf8, 0xb3, 0x34, 0x0b, 0x5f, 0x5f, 0x07, 0x54, 0x4c,
	0xd3, 0xb1, 0xe5, 0x41, 0x64, 0xab, 0x0b, 0xb3, 0x03, 0x68, 0x92, 0x6b, 0xe2, 0xa5, 0xd9, 0x65,
	0x34, 0xf1, 0xd8, 0xa3, 0x76, 0x04, 0x7e, 0x1a, 0x12, 0xfe, 0xff, 0xad, 0xc8, 0x87, 0x32, 0xde,
	0x92, 0x7f, 0xf0, 0xcb, 0x7f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x77, 0x78, 0xad, 0x26, 0x4e, 0x03,
	0x00, 0x00,
}

func (m *Params) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SignMode != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.SignMode))
		i--
		dAtA[i] = 0x28
	}
	if m.PruneAfter != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.PruneAfter))
		i--
		dAtA[i] = 0x20
	}
	if len(m.MinParticipation) > 0 {
		i -= len(m.MinParticipation)
		copy(dAtA[i:], m.MinParticipation)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.MinParticipation)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.QuorumFraction) > 0 {
		i -= len(m.QuorumFraction)
		copy(dAtA[i:], m.QuorumFraction)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.QuorumFraction)))
		i--
		dAtA[i] = 0x12
	}
	if m.EpochLength != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.EpochLength))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AttestationBitmap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttestationBitmap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AttestationBitmap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SoftConfirmed {
		i--
		if m.SoftConfirmed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.TotalPower != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.TotalPower))
		i--
		dAtA[i] = 0x20
	}
	if m.VotedPower != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.VotedPower))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Bitmap) > 0 {
		i -= len(m.Bitmap)
		copy(dAtA[i:], m.Bitmap)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Bitmap)))
		i--
		dAtA[i] = 0x12
	}
	if m.Height != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ValidatorIndex) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidatorIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValidatorIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Power != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Power))
		i--
		dAtA[i] = 0x18
	}
	if m.Index != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Params) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EpochLength != 0 {
		n += 1 + sovTypes(uint64(m.EpochLength))
	}
	l = len(m.QuorumFraction)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.MinParticipation)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.PruneAfter != 0 {
		n += 1 + sovTypes(uint64(m.PruneAfter))
	}
	if m.SignMode != 0 {
		n += 1 + sovTypes(uint64(m.SignMode))
	}
	return n
}

func (m *AttestationBitmap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Height != 0 {
		n += 1 + sovTypes(uint64(m.Height))
	}
	l = len(m.Bitmap)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.VotedPower != 0 {
		n += 1 + sovTypes(uint64(m.VotedPower))
	}
	if m.TotalPower != 0 {
		n += 1 + sovTypes(uint64(m.TotalPower))
	}
	if m.SoftConfirmed {
		n += 2
	}
	return n
}

func (m *ValidatorIndex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Index != 0 {
		n += 1 + sovTypes(uint64(m.Index))
	}
	if m.Power != 0 {
		n += 1 + sovTypes(uint64(m.Power))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Params) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Params: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochLength", wireType)
			}
			m.EpochLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochLength |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuorumFraction", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QuorumFraction = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinParticipation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MinParticipation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PruneAfter", wireType)
			}
			m.PruneAfter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PruneAfter |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignMode", wireType)
			}
			m.SignMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SignMode |= SignMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttestationBitmap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttestationBitmap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttestationBitmap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bitmap", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bitmap = append(m.Bitmap[:0], dAtA[iNdEx:postIndex]...)
			if m.Bitmap == nil {
				m.Bitmap = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VotedPower", wireType)
			}
			m.VotedPower = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VotedPower |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalPower", wireType)
			}
			m.TotalPower = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalPower |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SoftConfirmed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SoftConfirmed = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidatorIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidatorIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidatorIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Power", wireType)
			}
			m.Power = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Power |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
